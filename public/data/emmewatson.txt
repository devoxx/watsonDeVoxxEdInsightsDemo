alright good morning welcome Java nine is primarily going to be about modules this is probably not news to most of you here in the room but as as part of the bigger picture will have cut how does this fit in because after all Java is well my goodness is twenty years old this year I've been working on it for most of those years which is I don't know maybe the stake I'm not sure how how is the job has lasted this long wise it's still you know so popular well we've had a fairly basic method for evolving it we identify a pain point in the platform something that's affecting everybody you that whether they're developers deploy yours or users we figure out what the missing abstraction is and then we added to the platform if we do this right then it will look like something that has been there all along now we can't always do that sometimes Java has been criticized for being a platform that wears its history on its sleeve and that's largely because of the strong commitment we've always had compatibility but we've been reasonably successful here and there not least abstractions might be big generics are lambda's they might be small at the missing method or a class or or or or package you know the point is to have a coherent evolutionary path where you figure out a motivation for something you know if we don't do a feature because it's cool we don't just out a language feature because OCR passive %HESITATION we do it because it makes sense for the platform that we have in the platform as we see it going forward we're always trying to preserve jobs key values readability simplicity universality incompatibility so exit some examples of some of these big changes here already mentioned generics this was a big big change in Java five the main pain point we were addressing there was the fact that until Java five most collections CV right right could the manipulates collections it was essentially dynamically typed still strongly typed typed but it was dynamically typed you may go a list of strings and you pull something out of it well all the compiler roses it's an object in you have to go cast string which is tedious and then you might make a mistake somewhere and I was just very very painful collections classes in particular became much easier to use once we had generic types a second big change a big big a change to the platform was the introduction of lambda's Java eight the pain point there was it was just enormously hard to express code as data to move code around to be able to abstract over behavior so that we could write frameworks that would make it easy to to to exploit a large large multi core processors the land is were the answer there in Java nine were looking to address to pain points and it turns out they have we think the common solution one pain point is the class passed the brittle and error prone its path the other is the massive monolithic JDK the missing abstraction and a common solution here is the introduction of modules this is what we've been working on in project jigsaw in OpenJDK for awhile now and it's another example of of the long term investment in the platform but people know why the classpath is bad by now this this problem is so infamous that even own wikipedia entry can look it up your health drug hell is a term similar to DLL hell used to describe all the various ways in which the class loading process can end up not working yep here's classpath doctor this is from Hadoop which is likely to have a very well engineered system we spent some time using it as a case study for for modularization %HESITATION there are one hundred and ten jar files on this classpath how do you tell if something's missing up button well data that's hard how do you tell if there any conflicts %HESITATION build tools like maven could do a pretty good job based on artifact name but if the artifacts themselves have different name but sing contents there could be conflict and you won't find out until you have a nasty bug %HESITATION after your system's been up and running for two days is it safe to change an internally PI mum what's an internally PI this is the class path right the client the classpath is your jar files are not components is the fundamental problem drop files are just containers are filesystems on sticks you stick them in a row and you search them linearly from front to back looking for looking for a class classpath is a way to look up classes regardless about what component there and what package therein or their intended use you think about it it's sort of amazing that systems like this even work they do so that's the class path there's the monolithic JDK the from the monolithic nature of the JDK from the very beginning it well at the beginning wasn't so bad because really smart Rimmer but it's grown it's big %HESITATION and this this pain point has several aspects one is that it doesn't fit on the small devices even even though they have small IT that devices that they have processors capable of running an SD class VM but you don't they don't necessarily have the memory to hold all of the JDK especially when your applications will you need is going to use a little part of it that's just a waste it's even a problem in the cloud you sure big machines have plenty of disk space and plenty of memory but in the cloud it's all about optimizing the use of hardware and if you've got thousands of images and each is carrying the whole copy of the JDK for an application that's only using a little bit of it well that's wasteful to the very case it it is just it's this monolithic system it's grown up from the beginning as one system over the years we've we've done what we could with the with the facilities that have been the language from the beginning to try to keep opponents reasonably separate from each other but there are inevitably some surprising connections because anything can refer to anything else somebody working on Cordova here can decide %HESITATION there's a convenient API over there in AWT out let's use it no problem well that makes sense when you're monolithic but not so much when you're not so we need tools to define proper components for the platform so that you can choose just what you need is the class about the right tool for the job %HESITATION will know %HESITATION as I said jar files are components in those who have the the those annoying questions about is anything missing is is anything conflicting how do you ensure consistency the tape to change internals these aren't questions we want have to ask the platform itself related problem is well because there's no such thing as an internal API we have a bunch of internal classes that people have used over the years in various such that various packages his name start with some or have have the string internal in them com some internal other other internal things and despite this having warned against using these for many many years as well if there's a web page I found the internet archive from nineteen ninety eight the documents this people who use them anyway well they're convenient you know basics before encoder sure why not it's there works you know in the case like that are just for convenience in the art of fighting developer laziness other cases like Sunday's gun safe wealth okay fair that's the only way you can do stuff like the problem with these internal API's is they become a significant maintenance burden for those of us who work on the JDK itself that make it difficult to evolve the platform perhaps more importantly they make it difficult to secure the platform the JDK has lots of packages many of them are public they're part of the official Essie standard a PR or they're supported for use as JDK specific API's but many of them are private always things that start with Linda those words were never intended for outside use I and some of them contain very powerful API's that can do the things like sons gun safe word or or reflection when you're running into a secure environment how do we keep potentially adversarial code from using this well we've got one method troubling security that manager check package access if you forget to invoke that method somewhere restrict package access guess what you may be looking at a CVS ten performance finally is it is another another issue now peak performance of Java is pretty good these days but start a performance continues to be stretching problem so monolithic JDK class power scalability maintainability security performance the problems of the classpath we think the missing abstraction here the common solution in the right tool for nuclear set of problems is modules now as proposed modules are not a layer built above the platform on top of it fared there it they're built deeply into it there a fundamental new kind of program component implemented in both the language and the virtual machine they go well beyond the classpath to provide two key features one is reliable configuration the other is strong encapsulation how do modules fit into the ontology that we already know well a model is a kind of a component what kind of components to we already have we have classes interfaces classes and interfaces get organized into packages and packages now get organized into modules so module is a collection of packages a container of packages it names the modules upon which it depends and it can export specific packages for use only by the modules that depend upon it how do we define a model well we were a little bit of code here's a model declaration very simple model declaration it says this is a model whose name is kaum dot food dog bark it names the modules upon which it depends in this case it requires some library model conduct it up as it exports to specific packages for use only by the modules that depend upon it it exports a package called com conducted operative alpha and another called conduct food a bar dot beta okay so is a construct in the Java programming language how we would we would you put it well by convention these decorations go in a file called model dash info dot Java the day it is kind of like packaged action voda Java the dashes there intentionally because that makes it invalid class name what do you do with adult Java file well of course you can pilot you run Java sea and you get a little classifier the compiled form of the model decoration we call that a model disk it has a site is not a somewhat different name in that form because we we intend overtime debt to be able to add additional information to it there you often up information at build time that's handy to put into a model descriptor but would be inappropriate to put in the declaration itself how do you package of a model well we could define some entirely new format but that would make adoption for a a a really tricky challenge so instead what we've done is defined modular jar files so modular jar file is a jar file looks like pretty much any other jar file but it has a module Dakshin put a class file at the root the beauty of modular jar files is if you build them properly you can you can make it so that if a modular jar file can work as a module on job annihilator and it can work as a regular jar file on the class pass on Java eight and earlier because in those early releases don't just ignore the model described so we have our model come foobar it requires come through Baz which also has its its model declaration %HESITATION and say we've got another model come through app which is our actual application and it uses the comprobar library and maybe it doesn't sequel now what about the platform itself yeah where where's gobbling object purrs troubling string where's where's Ohio weld we use the same kinds of declarations define those we started with with this graph I met many years ago when we began this effort %HESITATION a as you can see it's it's quite quite the bowl of spaghetti %HESITATION the idiom important thing here is is the base model way up there move in red that the base model is the model that you always need it has fundamental things in it like juggling object and juggling system and troubling string they might ask the question okay expose Edgewater print how hello world how many of the modules in the system well I need and the answer is kind of depressing because well everything can referred everything else and so caught my gosh is to print hello world all need to leave Jack's peeper Sir all need Corbeau %HESITATION all need some JDBC stuff what thing at what's going on here well what's going on here is a couple of decades worth of technical debt which with over several years of paint painstaking work we managed to clean up I and eventually come up with something much simpler to understand so this this is the V. S. S. E. part of the model graph in the current the grin jigsaw prototype builds as you can see job at a base the base model is at the bottom a lot of things depend on it the base model doesn't then anything else you wanna print hello world all you need is the base model so this graph is defined by all of the dependence relationships amongst the esee modules and as I said these are defined in model declarations %HESITATION here's the declaration for the base model it requires nothing it exports whole bunch of stuff surprises in this list every module implicitly requires Java base you can write requires Java base if you want to but if you doubt the compiler will inserted concert at forty Java base is the only model that requires no others and it's the only model that's known specifically to the language and the virtual machine now how our platform outils packaged well we could use modular jar files at least for some of them about a lot many of the JDK modules have of native code him in them there configuration files and licenses and other stuff that you need to need to carry around so we've devised a new format called jae mod files Ajay mud fud German files are sort of jar files on on steroids they have they handled native code and all this other stuff either they're not intended really for fusion they're more of a transport format used to build a JDK the JDK intricately like images alright so we've got our our our three modules an app module to the library modules we've got the platform modules and we want to we want a runner out so all of these modules collectively will refer to them as the observable modules to make use of them at either compile time or runtime and we try to treat both as uniformly as we can we need to figure out how the modules relate to each other based just on what this app needs so what we do well we interpret the model declarations by reading the model info but class files we start with with confluent it requires com fubar ally in it requires got sequel okay so we're we're building a raft and %HESITATION yes it requires Java based because every model requires Java base we look at our next declaration a comp comp foobar it requires compu Baz it exports and things and it depends on the holidays contraband as exports some stuff I did only depends upon goddess drop a sequel requires logging everybody's favorite logging in the eye and Java XML and governor base logging only requires database similarly requires database and based model itself requires nothing were done okay so transitive closure there you go very very simple computation so this graph expresses the notion of readable modules so one model can read another if it's got an error if it's gotten an arrow to that model in this graph readable modules are the basis of reliable configuration we can tell if something is nothing missing we can tell if if something's duplicated let's look at the comp to apple Montel declaration again suppose we add requires calm through whatever no we compiled which we compiled trait we try to run this well to compile time and runtime out there is no conflict or model compile time you'll get under message model not found at runtime you'll get an error message to when you start the Jerry when you run when you start the VM model come through whatever not found required by come through at you don't get a class def not found error ten minutes after application started you get this message right away so that's reliable configuration what about strong encapsulation the strong encapsulation too is driven by the information in model declarations look at them again and and annotate this this multigraph that we built Kangoo out it doesn't export anything comprobar it exports comprobar often come through bart beta contraband as exports this this mobile package sequel exports a couple of things logging experts slugging XML exports a whole bunch of stuff and base sports even more steps and now we know not only have the modules relate to each other but what each module exports to the modules of the reader this is how we get the notion of accessible types code in one model can only access he typed in another model if that first model reads the second model and the second module exports the package containing that type accessible types are the basis of strong encapsulation so here's an example suppose in the convoy bar module we have a calm fubar beta internal you only meant for internal use and it's got some beta ample class that used across the entire comprobar module but is not meant for out outside use if conflagration port this and use it what will happen will at compile time you'll get an error message but it was not accessible because package Kongu Barbadian tornal is not exported if you manage the compiler by some some subterfuge because you're your code is out of sync or whatever and then you go to run it you also get an error message exception in thread main I won't read the whole thing but note that the the error message tells you would we would try to be very descriptive in the in these messages they tell you what cannot be accessed where it is and why it cannot be accessed so to recap the essence of the model system we have model declarations in Montreuil invoked a Java files we compile these into model descriptors model invoked a class files we package modules up either is modular jar files which are now proper software components rather than filesystems on sticks or dream on files for cases where we have native code we have the notion of observable modules we start with some set of modules that we we wished you some subset of we run the transitive closure computation to resolve model graph that gives us the notion of readable modules from readable modules we get reliable configuration and then finally by interpreting exports we have the notion of accessible types give us strong encapsulation these two properties reliable configuration strong encapsulation are uniformly enforced both compile time and runtime so the configurations of large systems are essentially correct alright going back to fourteen points see how modules help address them scalability whether to small devices are large department lard large devices as we've seen modules let us use only what we need how do we how do we get rid of the stuff that we don't need well to create custom runtime images that contain only what you need we've developed and developed a new tool a tool that I remember asking James Gosling about twenty years ago we why doesn't job I had a linker well there's obviously a time right it's mainly it's mainly mainly dynamic linking well what we've done is we've introduced a link or an optional linking step with a tool called Jay link trailing takes in modular jar files and and orgy mod files front yet runs the resolution album figure figures out the small set of modules that you need and then creates a custom runtime image only contains those modules so if you have an application that only needs no sequel XML base %HESITATION and and arm I then you can build a minimal runtime that contains just those plus your application all in one night nice tidy package ready to put in a doctor imager or what everyone for performance we've taken the opportunity to restructure the internals of the Java runtime to it to enable a a bunch of interesting kinds of future work so currently in Java Java eight and this goes way way back to one not to right runtime this is laid up this way there's there's a bin directory lib directory I'm endorsed axed argue duck jar and and and and a bunch of other bunch of other stuff we've we've fairly completely redundant so this is a change that is affecting tools and and some applications into a cleaner form we've set we've separated out configuration files from the lib directory than ever they don't belong there we put them in a place that makes it clear okay these are things that you can edit to configure your runtime environment we put things in into the lib directory any of that are are mainly intended for any of these are these are parts phenomenal parts of the platform that you shouldn't mess with if you do then you're probably playing with fire we've gotten rid of a number of things the endorsed standards mechanism is gone the extension mechanism is gone RT Dutch art is gone the platforms classes are no longer carried around in a drawer file which is pretty much the most inefficient format you could possibly choose store classes and a runtime system it's that we've developed a new format happens to be called Jay image it's it's very efficient highly optimized I intentionally not documented because we want to retain the right to change it over time to make it better so this new format it this will enable all kinds of of of cool stuff jape the jailing tool has as plugins for example that a lot that make it possible to compress things in a custom way to omit information that you don't need a new runtimes %HESITATION and we're also looking at how to integrate ahead of time compilation and ahead of time class data sharing thing things like that into this framework to improve startup time security maintainability so we are going to conceal most internal API's the JDK behind the strong encapsulation boundary defined by modules this is going to break some libraries and existing libraries and applications now we know that some of these internal API's are very broadly used and we know we know the plot lots of lots of interesting products and and libraries dependence there so we're not going to take them all away right away the ones that are very broadly used will remain available in Japan in JDK nine we are we've been working for several years now on defining public supported replacements for those API's as the as these the support replacements become available the old ones will fade away after allowing usually of a full release cycle for people to adopt some of the the the more obscure internal ATI's which there some evidence that some libraries replication views were we're just going to hide there is a way to get at them via a command line fly fair for all of this there's a tool called jade depths we databases in JDK eight there's an enhanced version of it in in the JD canine early access builds trade ups is a sort of a Swiss army knife of static analysis for drug files you can run J. that's on a jar file you can ask asking analyze my you submitted the internals and it will it will go through and tell you at least for static analysis point of view what internally guys are using it will even suggest what you should use instead so if you want if you want to start preparing for JDK nine today you run this tool on your jar files figure out where you're using internal API's and work to remove those uses finally the class path weld with with with modules and and and the model system we're providing the tools so that you can bring the benefits of of reliable configuration and strong encapsulation to your own code but it's up to you to use them wisely it's a long road ahead we do not expect modules to be adopted as rapidly as some other features we don't expect Java nine to be adopted as rapidly as some other releases and this is due due to a few reasons one as well this year nine is going to be a fairly disruptive release wean concealing internally PRI's getting rid of of some some old crafty features yeah some some stuff is going to break and that will slow adoption another reason is that well it's just it's just the nature of of the Richard modules are not lambda lambda lambda was a jet pack right you could you could read about it if you get worked up going right away you could write little examples you didn't change a whole bunch of stuff in your system to leverage modules are not a jetpack modules are more of a seatbelt they they make it safer so they can build large systems more and more quickly but it it will it takes relatively more work to get going with them so jigsaw itself has as been a fairly long road we started working on this problem out back in two thousand eight it's it's it's it's been a long road there is that there's a bit more left ago it's an example of another long term investment generics or lambda's where I see a pain point we had we we think we know what the missing abstraction is but we take the time to get it right because we want modules to be a strong foundation for job is next twenty years so I've barely scratched the surface in the time I've had here there's lots more to learn my colleague Allan Bateman and I are giving multiple sessions this week to begin to projects jigsaw in more details the day we have prepared for JDK nine which is mainly about the the incompatible changes in nine %HESITATION introduction the modular development is is kind of of the first baby steps into okay what is a model how do they work how do you practice advanced modular development covers the problem of how to migrate an existing application either from the top down or the bottom up or some combination to if you have additional questions that we don't answer in sessions you can come to ask the JDK architects section on Thursday %HESITATION Alan I will be there along with a couple of other folks from work all you can ask us about jigsaw or anything else that you like and then finally for the four into real rocket scientist level stuff projects are under the hood on Thursday covers the real science of the module of modules in the market system the semantics how everything works but in in some of the details so this is a big change it's still proposal on you we we really value questions and feedback that we get here so I'd encourage you to come to the sessions for more information of all all of our work is documented either in JDK enhancement proposals which can find on the OpenJDK website well there are are five jobs two hundred to a one two twenty two sixteen to sixty one in the model system itself is going to be a feature of the Java Essie platforms who it has its own JSR JSR three seventy six thank you very much.